group prettyprint;

/** Defining the grammar specfication template */
apeg(name, rules) ::= <<
/**
 *  APEG Tool Parser 
 *  This code was automatically generated by APEG Parser Generator.
 *  Last modification 27/04/2018
 */
public class <name> extends StateFullBaseParser{

      public <name>(String fname) {
          super(fname);
          startRule("root");
      }

      <rules; separator="\n\n"> 
}
>>


/** Template for rules specification */
rule( name, peg_expr) ::= <<
public PegResult <name>(){
   startRule("<name>");
   <peg_expr>
   return fail(); 
}>>

/** Template for parsing expression 
  *
  */
choice_peg(left_peg, right_peg) ::= 
<<mkBacktracPoint();
<left_peg>
if(isOk()){ return success();}
restore();    
mkBacktracPoint();
<right_peg>
>>

sequence_peg(peg_exprs,fail) ::=  "<peg_exprs:{x | if(isOk()){<x>\}  }; separator=\"\n\" >" 

cont(expr1,expr2) ::=
<<
<expr1>
<if(expr2)>if(isOK()){
    <expr2>
}<endif>>>

match(value)::= <<match("<value>");>> 
call(name) ::= << <value>();>>

star_peg(peg_expr) ::= 
<<
do{
   mkBacktracPoint();
   <peg_expr>
   if(!isOK()){restore();}esle{dismissBacktracPoint();}
}while(isOk());
done();
>>


and_peg(peg_expr) ::= 
<<
mkBacktracPoint
<peg_expr>
restore();>>

any_peg(suc,fail) ::=
<<
if(matchNext()){ return <suc>;}
return <fail>;
>>

bind_peg(name, peg_expr) ::="<name>=<peg_expr>"

constraint_peg(expr) ::= "{? <expr> }"

group_peg(ranges) ::= "[<ranges>]"
lambda_peg() ::= " " 

not_peg(peg_expr, suc, fail) ::= 
<<
mark();
if(!<peg_expr>){
   restore();
   return <suc>;
}
restore();
return <fail>
>>

plus_peg(peg_expr,suc,fail) ::= 
<<
if(!<peg_expr>){ return <fail>;}
while(<peg_expr>){}
return <suc>;
>>

optional_peg(peg_expr, suc) ::= 
<<
mark();
if(!<peg_expr>){
   restore();
}
return <suc>; 
>>
update_peg(assigns) ::= <<{<assigns; separator=" ">}>>
