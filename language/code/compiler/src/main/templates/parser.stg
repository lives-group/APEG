group prettyprint;

/** Defining the grammar specfication template */
apeg(name, rules) ::= <<

public class <name> extends BaseParser{

      public <name>(String fname) {
          super(fname);
          startRule("root");
      }

      <rules; separator="\n\n"> 
}
>>


/** Template for rules specification */
rule( name, peg_expr, suc_or_fail) ::= <<
public boolean <name>(){
   startRule("<name>");
   <peg_expr>
   <if(suc_or_fail)>
   return <suc_or_fail>; 
   <endif>}>>

temp( name, peg_expr, suc_or_fail) ::= <<
private boolean <name>(){
   <peg_expr>
   <if(suc_or_fail)>
   return <suc_or_fail>;
   <endif>
}>>

choice_peg(left_peg, right_peg, suc) ::= 
<<mark();
if(<left_peg>){ 
   unmark(); 
   return <suc>;
}
restore();
alternate();
<right_peg> 
>>
  
sequence_peg(peg_exprs) ::=  "<peg_exprs:{x | if(!<x>){return endFail();\}  }; separator=\"\n\" >" 

peg_literal_test(value)::= 
<<if(!match("<value>")){ 
     return endFail();
}
>> 

peg_literal_match(value)::= <<match("<value>")>> 

peg_nonterminal_call(value) ::= << <value>() >>

literal_peg(value, choice, star, lit) ::= << 
<if(choice)>match("<value>")<endif>
<if(star)>match("<value>")<endif>
<if(lit)>
if(!match("<value>")){ 
    return endFail();
}<endif> >>

star_peg(peg_expr) ::= <<while(<peg_expr>){}>>

/** Template for parsing expression */
and_peg(peg_expr, suc,fail) ::= 
<<
mark();
if(!<peg_expr>){ 
     restore();
     <if(fail)>
     return <fail>;
     <endif>}
restore();
<if(suc)>return <suc>;<endif> >>
any_peg() ::= "."

bind_peg(name, peg_expr) ::="<name>=<peg_expr>"

constraint_peg(expr) ::= "{? <expr> }"
group_peg(ranges) ::= "[<ranges>]"
lambda_peg() ::= " " 

not_peg(peg_expr, suc, fail) ::= 
<<
mark();
if(!<peg_expr>){
   restore();
   return <suc>;
}
restore();
return <fail>
>>

plus_peg(peg_expr) ::= "(<peg_expr>)+"
optional_peg(peg_expr, suc) ::= 
<<
mark();
if(!<peg_expr>){
   restore();
}
return <suc>; 
>>
update_peg(assigns) ::= <<{<assigns; separator=" ">}>>
