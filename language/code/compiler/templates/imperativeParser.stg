group prettyprint;

/** Defining the grammar specfication template */
apeg(name, rules) ::= <<
/**
 *  APEG Tool Parser
 *  This code was automatically generated by APEG Parser Generator.
 *  Last modification 27/04/2018
 */
public class <name> extends StateFullBaseParser{

      public <name>(String fname) {
          super(fname);
          startRule("root");
      }

      <rules; separator="\n\n">
}
>>


/** Template for rules specification */
rule( name, peg_expr, aridade) ::= <<
public PegResult <name>(Object[] v){
   startRule("<name>");
   Object[] copy;
   Object[] list_param;
   Object[] v_restore;
   <peg_expr>
   if(isOk()){return success();} else{return fail();}
}>>

/** Template for parsing expression
  *
  */
choice_peg(left_peg, right_peg) ::=
<<mkBacktracPoint();
v_restore = v.copy();
<left_peg>
if(isOk()){ return success();}
restore();
v = v_restore;
mkBacktracPoint();
v_restore = v.copy();
<right_peg>
if(isOk()){ return success();}
>>


cont(expr1,expr2) ::=
<<
<expr1><if(expr2)>
if(isOk()){
    <expr2>
}<endif> >>

match(value)::= <<match("<value>");>>
call(name) ::=
<<<name>(list_param);>>

and(peg_expr) ::=
<<
mkBacktracPoint();
v_restore = v.copy();
<peg_expr>
restore();
v = v_restore;>>

star_peg(peg_expr) ::=
<<
do{
   mkBacktracPoint();
   v_restore = v.copy();
   <peg_expr>
   if(!isOk()){restore(); v = v_restore;} else{dismissBacktracPoint();}
}while(isOk());
done();
>>

plus_peg(peg_expr) ::=
<<
<peg_expr>
if(!isOk()){
 return fail();
}
do{
   mkBacktracPoint();
   v_restore = v.copy();
   <peg_expr>
   if(!isOk()){restore(); v = v_restore;} else{dismissBacktracPoint();}
}while(isOk());
done();
>>

not_peg(peg_expr) ::=
<<
mkBacktracPoint();
v_restore = v.copy();
<peg_expr>
if(isOk()){ restore(); v = v_restore; fail();}
else{
    dismissBacktracPoint();
    done();
}
>>


optional_peg(peg_expr) ::=
<<
mkBacktracPoint();
v_restore = v.copy();
<peg_expr>
if(isOk()){ dismissBacktracPoint();}
else{ restore(); v = v_restore; done(); }
>>

any_peg() ::=
<<
matchNext();
if(isOk()){ return endSuccess();}
>>

lambda_peg() ::= " "

bind_peg(name, peg_expr) ::="<name>=<peg_expr>"

constraint_peg(expr) ::= "{? <expr> }"

group_peg(ranges) ::= "[<ranges>]"

update_peg(assigns) ::= <<{<assigns; separator=" ">}>>

attr(name, expr) ::= "<name> = <expr>;"

var(type, name) ::= "((<type>) <name>)"

var_decl(type, name) ::= "<type> <name>;"

uexpr(exprl,op) ::= "<op> <exprl>"

lit(expr) ::= "<expr>"

bexpr(exprl, exprr,op) ::= "<exprl> <op> <exprr>"

seq_expr(exprs) ::=  <<<exprs; separator="\n"> >>

access_key(name,key,type)::= << (<type>) <name>[<key>] >>

record_key(name,key,value) ::= <<<name>[<key>] = <value>; >>

iniParamList(env,key,value) ::= <<<env>[<key>] = <value>; >>

copy(ninh,var,var_copy,menor)::= <<for(int i=0;i<menor><ninh>;i++) {<var_copy>[i]=<var>[i];}>>

inst_object(name,size)::= <<<name> = new Object[<size>];>>
