group prettyprint;

/** Defining the grammar specfication template */
apeg(name, option, rules) ::= <<
apeg <name>;
<if(option)>

options {
  <option; separator=";\n">;
}
<endif>

<rules; separator="\n\n">
>>


/** Template for rules specification */
rule(annotation, name, inh, syn, peg) ::= <<
<if(annotation)>
@<annotation> 
<endif>
<name><if(inh_attr)>[<inh; separator=", ", wrap>]<endif><if(syn)> returns[<syn; separator=", ", wrap>]<endif>:
  <peg>
;
>>


/** Template for parameters declaration */
decl(type, name) ::= "<type> <name>"


/** Template for types */
boolean_type() ::= "boolean"
char_type() ::= "char"
float_type() ::= "float"
grammar_type() :: "grammar"
int_type() ::= "int"
lang_type() ::= "lang"
map_type() ::= "map"
string_type() ::= "string"


/** Template for expressions */
atribute_expr(name) ::= "<name>"
attribute_grammar(name) ::= "$<name>"

gt_expr(left_expr, right_expr) ::= "(<left_expr> > <right_expr>)"
ge_expr(left_expr, right_expr) ::= "(<left_expr> \>= <right_expr>)"
lt_expr(left_expr, right_expr) ::= "(<left_expr> \< <right_expr>)"
le_expr(left_expr, right_expr) ::= "(<left_expr> \<= <right_expr>)"
mul_expr(left_expr, right_expr) ::= "(<left_expr> * <right_expr>)"
div_expr(left_expr, right_expr) ::= "(<left_expr> / <right_expr>)"
mod_expr(left_expr, right_expr) ::= "(<left_expr> % <right_expr>)"
add_expr(left_expr, right_expr) ::= "(<left_expr> + <right_expr>)"
sub_expr(left_expr, right_expr) ::= "(<left_expr> - <right_expr>)"

equals_expr(left_expr, right_expr) ::= "(<left_expr> == <right_expr>)"
no_equals_expr(left_expr, right_expr) ::= "(<left_expr> != <right_expr>)"

boolean_expr(value) ::= "<value>"
char_expr(value) ::= "<value>"
float_expr(value) ::= "<value>"
int_expr(value) ::= "<value>"
/** map lit  --> Pair<expr, expr> */
string_expr(value) ::= "'<value>'"
meta_expr(expr) ::= "@[ <expr> ]"
minus_expr(expr) ::= "-<expr>"
not_expr(expr) ::= "!<expr>"
or_expr(left_expr, right_expr) ::= "(<left_expr> || <right_expr>)"
and_expr(left_expr, right_expr) ::= "(<left_expr> && <right_expr>)"


/** Template for parsing expression */
and_peg(peg_expr) ::= "&<peg_expr>"
any_peg() ::= "."
bind_peg(name, peg_expr) ::="<name>=<peg_expr>)"
choice_peg(left_peg, right_peg) ::= <<
 <left_peg>
/
<right_peg>
>>
constraint_peg(expr) ::= "{? <expr> }"
group_peg(ranges) ::= "[<ranges>]"
literal_peg(value) ::= "'<value>'"
lambda_peg() ::= " " 
nonterminal_peg(name, attrs) ::= "<name>\<<attrs; separator=\", \", wrap>>"
not_peg(peg_expr) ::= "!(<peg_expr>)"
plus_peg(peg_expr) ::= "(<peg_expr>)+"
optional_peg(peg_expr) ::= "(<peg_expr>)?"
sequence_peg(peg_exprs) ::= "<peg_exprs:{x | <x>}; separator=\" \">"
star_peg(peg_expr) ::= "(<peg_expr>)*"
update_peg(assigns) ::= <<{<assigns; separator=" ">}>>


/** Template for assignment from update parsing expressions */
assign(name, expr) ::= "(<name> = <expr>);"


/** func(f) ::= "<f>"  Not implemented yet */



