// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// on Quinta-feira, 15 de Julho de 2021 at 18:05:58.
// Edit at your own risk.
// ===========================================================================

package parsers.rats.xml;

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>parsers.rats.xml.xml</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */
public final class xml extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fElement;
    Result fElement$$Star1;
    Result fElement$$Star2;
    Result f$$Shared1;
    Result fRef;
    Result fQName;
    Result fNCName;
    Result fNCName$$Star1;
    Result fPI;
    Result fComment;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fComment$$Star1;
    Result fspacing;
    Result fMisc;
    Result fYesNo;
    Result fEncodingName;
    Result fEncodingName$$Star1;
    Result fVersionNum;
    Result fSystemLit;
    Result fSystemLit$$Star1;
    Result fSystemLit$$Star2;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fPubIDChar;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class xmlColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public xml(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public xml(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new xmlColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Document.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDocument(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrologue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pElement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEpilogue(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Element.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElement(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fElement) 
      yyColumn.chunk1.fElement = pElement$1(yyStart);
    return yyColumn.chunk1.fElement;
  }

  /** Actually parse parsers.rats.xml.xml.Element. */
  private Result pElement$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = p$$Shared1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pElement$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = pspacing(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          final int yyChoice1 = yyOption1;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '/':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('>' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '>':
              {
                yyResult = pElement$$Star2(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if ('<' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyC = character(yyIndex);
                    if ('/' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = p$$Shared1(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;

                        yyResult = pspacing(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {

                          yyOption1  = yyResult.index;
                        }

                        yyBase = yyOption1;
                        yyC    = character(yyBase);
                        if ('>' == yyC) {
                          yyIndex = yyOption1 + 1;

                          yyValue = null;

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("'>' expected", yyBase);
                        }
                      }
                    } else {
                      yyError = yyError.select("'</' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'</' expected", yyBase);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("element expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.Element$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElement$$Star1(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fElement$$Star1) 
      yyColumn.chunk1.fElement$$Star1 = pElement$$Star1$1(yyStart);
    return yyColumn.chunk1.fElement$$Star1;
  }

  /** Actually parse parsers.rats.xml.xml.Element$$Star1. */
  private Result pElement$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pspacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAttribute(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pElement$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.Element$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElement$$Star2(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fElement$$Star2) 
      yyColumn.chunk1.fElement$$Star2 = pElement$$Star2$1(yyStart);
    return yyColumn.chunk1.fElement$$Star2;
  }

  /** Actually parse parsers.rats.xml.xml.Element$$Star2. */
  private Result pElement$$Star2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pContent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pElement$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Content.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pPI(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pRef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('[' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('C' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('D' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('A' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('T' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('A' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('[' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = pCData(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyBase = yyResult.index;
                        yyC    = character(yyBase);
                        if (']' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyC = character(yyIndex);
                          if (']' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('>' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("']]>' expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("']]>' expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("']]>' expected", yyBase);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 6.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyPredMatched = false;

      yyPredResult = pCharData$$Choice1(yyRepetition1);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      } else {
        yyError = yyError.select("content expected", yyStart);
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * parsers.rats.xml.xml.ElemName and parsers.rats.xml.xml.AttrName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared1) 
      yyColumn.chunk1.f$$Shared1 = p$$Shared1$1(yyStart);
    return yyColumn.chunk1.f$$Shared1;
  }

  /** Actually parse parsers.rats.xml.xml.$$Shared1. */
  private Result p$$Shared1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.CharData$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharData$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '&':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '<':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("char data expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.CData.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCData(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyPredMatched = false;

      yyC = character(yyRepetition1);
      if (']' == yyC) {
        yyPredIndex = yyRepetition1 + 1;

        yyC = character(yyPredIndex);
        if (']' == yyC) {
          yyPredIndex = yyPredIndex + 1;

          yyC = character(yyPredIndex);
          if ('>' == yyC) {

            yyPredMatched = true;
          }
        }
      }

      if (! yyPredMatched) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          yyRepetition1 = yyIndex;
          continue;
        }
      } else {
        yyError = yyError.select("c data expected", yyStart);
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Ref.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRef(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fRef) yyColumn.chunk1.fRef = pRef$1(yyStart);
    return yyColumn.chunk1.fRef;
  }

  /** Actually parse parsers.rats.xml.xml.Ref. */
  private Result pRef$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('&' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;
          if ('#' == yyC) {

            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;
              if ('x' == yyC) {

                yyRepetition1 = yyIndex;
                yyRepeated1   = false;
                while (true) {

                  yyC = character(yyRepetition1);
                  if (-1 != yyC) {
                    yyIndex = yyRepetition1 + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'f':
                      {
                        yyRepetition1 = yyIndex;
                        yyRepeated1   = true;
                        continue;
                      }

                    default:
                      /* No match. */
                    }
                  }
                  break;
                }

                if (yyRepeated1) {

                  yyC = character(yyRepetition1);
                  if (';' == yyC) {
                    yyIndex = yyRepetition1 + 1;

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            yyRepeated1   = false;
            while (true) {

              yyC = character(yyRepetition1);
              if (-1 != yyC) {
                yyIndex = yyRepetition1 + 1;

                switch (yyC) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  {
                    yyRepetition1 = yyIndex;
                    yyRepeated1   = true;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
              break;
            }

            if (yyRepeated1) {

              yyC = character(yyRepetition1);
              if (';' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pNCName(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyC = character(yyResult.index);
          if (';' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("ref expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Attribute.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttribute(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyResult = pspacing(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyC = character(yyOption1);
      if ('=' == yyC) {
        yyIndex = yyOption1 + 1;

        yyOption1  = yyIndex;

        yyResult = pspacing(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyResult = pAttValue(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("attribute expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.AttValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttValue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyResult = pDoubleQuotedPart(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
            break;
          }

          yyC = character(yyRepetition1);
          if ('\"' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
        break;

      case '\'':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyResult = pSingleQuotedPart(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
            break;
          }

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('\'' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'\\\'' expected", yyBase);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("att value expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.DoubleQuotedPart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoubleQuotedPart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyPredMatched = false;

      yyPredResult = pDoubleQuotedPart$$Choice1(yyRepetition1);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      } else {
        yyError = yyError.select("double quoted part expected", yyStart);
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Alternative 2.

    yyResult = pRef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("double quoted part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * parsers.rats.xml.xml.DoubleQuotedPart$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoubleQuotedPart$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '&':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\"':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '<':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("double quoted part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.SingleQuotedPart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleQuotedPart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyPredMatched = false;

      yyPredResult = pSingleQuotedPart$$Choice1(yyRepetition1);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      } else {
        yyError = yyError.select("single quoted part expected", yyStart);
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Alternative 2.

    yyResult = pRef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("single quoted part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * parsers.rats.xml.xml.SingleQuotedPart$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleQuotedPart$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '&':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\'':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '<':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("single quoted part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.QName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQName(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fQName) 
      yyColumn.chunk1.fQName = pQName$1(yyStart);
    return yyColumn.chunk1.fQName;
  }

  /** Actually parse parsers.rats.xml.xml.QName. */
  private Result pQName$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyResult = pQualifier(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
    }

    yyResult = pNCName(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Qualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifier(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyOption1  = yyIndex;

      yyResult = pspacing(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyResult = pNamespaceURI(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyResult = pspacing(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyC = character(yyOption1);
        if ('}' == yyC) {
          yyIndex = yyOption1 + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNCName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyC = character(yyResult.index);
      if (':' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("qualifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.NCName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNCName(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNCName) 
      yyColumn.chunk1.fNCName = pNCName$1(yyStart);
    return yyColumn.chunk1.fNCName;
  }

  /** Actually parse parsers.rats.xml.xml.NCName. */
  private Result pNCName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNCName$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNCName$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.NCName$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNCName$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("n c name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.NCName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNCName$$Star1(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNCName$$Star1) 
      yyColumn.chunk1.fNCName$$Star1 = pNCName$$Star1$1(yyStart);
    return yyColumn.chunk1.fNCName$$Star1;
  }

  /** Actually parse parsers.rats.xml.xml.NCName$$Star1. */
  private Result pNCName$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pNCName$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '.':
        {
          yyResult = pNCName$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '-':
        {
          yyResult = pNCName$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '_':
        {
          yyResult = pNCName$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.NamespaceURI.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNamespaceURI(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;
        if ((('0' <= yyC) && (yyC <= '9')) ||
            (('A' <= yyC) && (yyC <= 'Z')) ||
            (('a' <= yyC) && (yyC <= 'z'))) {

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '_':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        case '-':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        case ':':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        case '/':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        case '.':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("namespace u r i expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.PI.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPI(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPI) yyColumn.chunk1.fPI = pPI$1(yyStart);
    return yyColumn.chunk1.fPI;
  }

  /** Actually parse parsers.rats.xml.xml.PI. */
  private Result pPI$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('?' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pPITarget(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = pspacing(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyResult = pPIChars(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }
          }

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if ('?' == yyC) {
            yyIndex = yyOption1 + 1;

            yyC = character(yyIndex);
            if ('>' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("'?>' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'?>' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("PI expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.PITarget.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPITarget(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNxml(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pNCName(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("p i target expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.PIChars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPIChars(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyPredMatched = false;

      yyC = character(yyRepetition1);
      if ('?' == yyC) {
        yyPredIndex = yyRepetition1 + 1;

        yyC = character(yyPredIndex);
        if ('>' == yyC) {

          yyPredMatched = true;
        }
      }

      if (! yyPredMatched) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          yyRepetition1 = yyIndex;
          continue;
        }
      } else {
        yyError = yyError.select("p i chars expected", yyStart);
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Nxml.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNxml(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNxml$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNxml$$Choice2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNxml$$Choice3(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyPredMatched = false;

          yyPredResult = pNCName(yyResult.index);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("nxml expected", yyStart);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.Nxml$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNxml$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'X':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'x':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("nxml expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.Nxml$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNxml$$Choice2(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'M':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'm':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("nxml expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.Nxml$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNxml$$Choice3(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'L':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'l':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("nxml expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fComment) 
      yyColumn.chunk1.fComment = pComment$1(yyStart);
    return yyColumn.chunk1.fComment;
  }

  /** Actually parse parsers.rats.xml.xml.Comment. */
  private Result pComment$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('-' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pComment$$Star1(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if ('-' == yyC) {
                yyIndex = yyResult.index + 1;

                yyC = character(yyIndex);
                if ('-' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('>' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("'-->' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'-->' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'-->' expected", yyBase);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.Comment$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment$$Star1(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fComment$$Star1) 
      yyColumn.chunk2.fComment$$Star1 = pComment$$Star1$1(yyStart);
    return yyColumn.chunk2.fComment$$Star1;
  }

  /** Actually parse parsers.rats.xml.xml.Comment$$Star1. */
  private Result pComment$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyPredIndex;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if ('-' == yyC) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyResult = pComment$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } else {
      yyError = yyError.select("comment expected", yyStart);
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pspacing(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fspacing) 
      yyColumn.chunk2.fspacing = pspacing$1(yyStart);
    return yyColumn.chunk2.fspacing;
  }

  /** Actually parse parsers.rats.xml.xml.spacing. */
  private Result pspacing$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pspacing(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\t':
              {
                yyResult = pspacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
              break;

            case '\r':
              {
                yyResult = pspacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyResult = pspacing(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 3.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\t':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '\r':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 4.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\t':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pspacing(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pspacing(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("spacing expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Prologue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrologue(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyResult = pXMLDecl(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
    }

    yyRepetition1 = yyOption1;
    while (true) {

      yyResult = pMisc(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyOption1  = yyRepetition1;

    yyResult = pDocTypePrologue(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyOption1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Epilogue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEpilogue(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pMisc(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.Misc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMisc(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMisc) 
      yyColumn.chunk2.fMisc = pMisc$1(yyStart);
    return yyColumn.chunk2.fMisc;
  }

  /** Actually parse parsers.rats.xml.xml.Misc. */
  private Result pMisc$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPI(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pspacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.XMLDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXMLDecl(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('?' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('x' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pVersionInfo(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;

                yyResult = pEncodingDecl(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                }


                yyResult = pStandaloneDecl(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                }


                yyResult = pspacing(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                }

                yyBase = yyOption1;
                yyC    = character(yyBase);
                if ('?' == yyC) {
                  yyIndex = yyOption1 + 1;

                  yyC = character(yyIndex);
                  if ('>' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("'?>' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'?>' expected", yyBase);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("x m l decl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.StandaloneDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStandaloneDecl(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pspacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('s' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('l' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('o' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('n' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyOption1  = yyIndex;

                          yyResult = pspacing(yyOption1);
                          yyError  = yyResult.select(yyError, yyOption1);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                          }

                          yyC = character(yyOption1);
                          if ('=' == yyC) {
                            yyIndex = yyOption1 + 1;

                            yyOption1  = yyIndex;

                            yyResult = pspacing(yyOption1);
                            yyError  = yyResult.select(yyError, yyOption1);
                            if (yyResult.hasValue()) {

                              yyOption1  = yyResult.index;
                            }

                            yyResult = pStandaloneValue(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyValue = null;

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        } else {
                          yyError = yyError.select("'standalone' expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("'standalone' expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("'standalone' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'standalone' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'standalone' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'standalone' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'standalone' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'standalone' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'standalone' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'standalone' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("standalone decl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.VersionInfo.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVersionInfo(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pspacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('v' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('o' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyOption1  = yyIndex;

                    yyResult = pspacing(yyOption1);
                    yyError  = yyResult.select(yyError, yyOption1);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                    }

                    yyC = character(yyOption1);
                    if ('=' == yyC) {
                      yyIndex = yyOption1 + 1;

                      yyOption1  = yyIndex;

                      yyResult = pspacing(yyOption1);
                      yyError  = yyResult.select(yyError, yyOption1);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                      }

                      final int yyChoice1 = yyOption1;

                      // Nested alternative 1.

                      yyC = character(yyChoice1);
                      if (-1 != yyC) {
                        yyIndex = yyChoice1 + 1;

                        switch (yyC) {
                        case '\"':
                          {
                            yyResult = pVersionNum(yyIndex);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyC = character(yyResult.index);
                              if ('\"' == yyC) {
                                yyIndex = yyResult.index + 1;

                                yyValue = null;

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                          break;

                        case '\'':
                          {
                            yyResult = pVersionNum(yyIndex);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyC = character(yyResult.index);
                              if ('\'' == yyC) {
                                yyIndex = yyResult.index + 1;

                                yyValue = null;

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                  } else {
                    yyError = yyError.select("'version' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'version' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'version' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'version' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'version' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'version' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'version' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("version info expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.EncodingDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncodingDecl(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pspacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('e' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('g' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyOption1  = yyIndex;

                      yyResult = pspacing(yyOption1);
                      yyError  = yyResult.select(yyError, yyOption1);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                      }

                      yyC = character(yyOption1);
                      if ('=' == yyC) {
                        yyIndex = yyOption1 + 1;

                        yyOption1  = yyIndex;

                        yyResult = pspacing(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {

                          yyOption1  = yyResult.index;
                        }

                        final int yyChoice1 = yyOption1;

                        // Nested alternative 1.

                        yyC = character(yyChoice1);
                        if (-1 != yyC) {
                          yyIndex = yyChoice1 + 1;

                          switch (yyC) {
                          case '\"':
                            {
                              yyResult = pEncodingName(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyC = character(yyResult.index);
                                if ('\"' == yyC) {
                                  yyIndex = yyResult.index + 1;

                                  yyValue = null;

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                }
                              }
                            }
                            break;

                          case '\'':
                            {
                              yyResult = pEncodingName(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyBase = yyResult.index;
                                yyC    = character(yyBase);
                                if ('\'' == yyC) {
                                  yyIndex = yyResult.index + 1;

                                  yyValue = null;

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("'\\\'' expected", yyBase);
                                }
                              }
                            }
                            break;

                          default:
                            /* No match. */
                          }
                        }
                      }
                    } else {
                      yyError = yyError.select("'encoding' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'encoding' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'encoding' expected", yyBase);
                }
              } else {
                yyError = yyError.select("'encoding' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'encoding' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'encoding' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'encoding' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'encoding' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("encoding decl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.StandaloneValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStandaloneValue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          yyResult = pYesNo(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyC = character(yyResult.index);
            if ('\"' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\'':
        {
          yyResult = pYesNo(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('\'' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("'\\\'' expected", yyBase);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("standalone value expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.YesNo.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pYesNo(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fYesNo) 
      yyColumn.chunk2.fYesNo = pYesNo$1(yyStart);
    return yyColumn.chunk2.fYesNo;
  }

  /** Actually parse parsers.rats.xml.xml.YesNo. */
  private Result pYesNo$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'y':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('s' == yyC) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 'n':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("yes no expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.EncodingName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncodingName(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fEncodingName) 
      yyColumn.chunk2.fEncodingName = pEncodingName$1(yyStart);
    return yyColumn.chunk2.fEncodingName;
  }

  /** Actually parse parsers.rats.xml.xml.EncodingName. */
  private Result pEncodingName$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pEncodingName$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("encoding name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.EncodingName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncodingName$$Star1(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fEncodingName$$Star1) 
      yyColumn.chunk2.fEncodingName$$Star1 = pEncodingName$$Star1$1(yyStart);
    return yyColumn.chunk2.fEncodingName$$Star1;
  }

  /** Actually parse parsers.rats.xml.xml.EncodingName$$Star1. */
  private Result pEncodingName$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pEncodingName$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '.':
        {
          yyResult = pEncodingName$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '_':
        {
          yyResult = pEncodingName$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '-':
        {
          yyResult = pEncodingName$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.VersionNum.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVersionNum(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fVersionNum) 
      yyColumn.chunk2.fVersionNum = pVersionNum$1(yyStart);
    return yyColumn.chunk2.fVersionNum;
  }

  /** Actually parse parsers.rats.xml.xml.VersionNum. */
  private Result pVersionNum$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pVersionNum(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '.':
        {
          yyResult = pVersionNum(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '_':
        {
          yyResult = pVersionNum(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case ':':
        {
          yyResult = pVersionNum(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '-':
        {
          yyResult = pVersionNum(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '.':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("version num expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.DocTypePrologue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDocTypePrologue(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDocTypeDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyResult = pMisc(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.DocTypeDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDocTypeDecl(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('D' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('O' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('C' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('T' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('Y' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('P' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('E' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = pspacing(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pQName(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pspacing(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pExternalID(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyC = character(yyResult.index);
                              if ('>' == yyC) {
                                yyIndex = yyResult.index + 1;

                                yyValue = null;

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("doc type decl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.ExternalID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExternalID(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'S':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('Y' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('S' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('T' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('M' == yyC) {

                              yyResult = pspacing(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pSystemLit(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyValue = null;

                                  return yyResult.createValue(yyValue, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'P':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('U' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('B' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('L' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('I' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('C' == yyC) {

                              yyResult = pspacing(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pPublicLit(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pspacing(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pSystemLit(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      yyValue = null;

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("external i d expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.SystemLit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSystemLit(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSystemLit) 
      yyColumn.chunk2.fSystemLit = pSystemLit$1(yyStart);
    return yyColumn.chunk2.fSystemLit;
  }

  /** Actually parse parsers.rats.xml.xml.SystemLit. */
  private Result pSystemLit$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          yyResult = pSystemLit$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyC = character(yyResult.index);
            if ('\"' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\'':
        {
          yyResult = pSystemLit$$Star2(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('\'' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("'\\\'' expected", yyBase);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("system lit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.SystemLit$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSystemLit$$Star1(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSystemLit$$Star1) 
      yyColumn.chunk2.fSystemLit$$Star1 = pSystemLit$$Star1$1(yyStart);
    return yyColumn.chunk2.fSystemLit$$Star1;
  }

  /** Actually parse parsers.rats.xml.xml.SystemLit$$Star1. */
  private Result pSystemLit$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('\"' != yyC) {

        yyResult = pSystemLit$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal parsers.rats.xml.xml.SystemLit$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSystemLit$$Star2(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSystemLit$$Star2) 
      yyColumn.chunk2.fSystemLit$$Star2 = pSystemLit$$Star2$1(yyStart);
    return yyColumn.chunk2.fSystemLit$$Star2;
  }

  /** Actually parse parsers.rats.xml.xml.SystemLit$$Star2. */
  private Result pSystemLit$$Star2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('\'' == yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyResult = pSystemLit$$Star2(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } else {
      yyError = yyError.select("system lit expected", yyStart);
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.PublicLit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPublicLit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyResult = pPubIDChar(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
            break;
          }

          yyC = character(yyRepetition1);
          if ('\"' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
        break;

      case '\'':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyPredMatched = false;

            yyC = character(yyRepetition1);
            if ('\'' == yyC) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyResult = pPubIDChar(yyRepetition1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                continue;
              }
            } else {
              yyError = yyError.select("public lit expected", yyStart);
            }
            break;
          }

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('\'' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'\\\'' expected", yyBase);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("public lit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal parsers.rats.xml.xml.PubIDChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPubIDChar(final int yyStart) throws IOException {
    xmlColumn yyColumn = (xmlColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPubIDChar) 
      yyColumn.chunk3.fPubIDChar = pPubIDChar$1(yyStart);
    return yyColumn.chunk3.fPubIDChar;
  }

  /** Actually parse parsers.rats.xml.xml.PubIDChar. */
  private Result pPubIDChar$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\n':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\t' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\'':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '+':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ';':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '!':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '*':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '#':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '@':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '$':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '%':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("pub i d char expected", yyStart);
    return yyError;
  }

}
